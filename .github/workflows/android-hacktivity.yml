name: üì± Android HackerOne Reports

on:
  workflow_dispatch:  # manual trigger
  schedule:
    - cron: '0 12 * * *'  # runs every day at 12:00 UTC

jobs:
  scrape-android-reports:
    runs-on: ubuntu-latest

    steps:
    - name: üì• Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Needed to access all branches

    - name: üêç Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: üì¶ Install dependencies
      run: |
        pip install selenium webdriver-manager beautifulsoup4 requests pandas 

    - name: üß© Install Chrome
      run: |
        sudo apt-get update
        sudo apt-get install -y google-chrome-stable

    - name: üì• Fetch Existing SQLite DB from data-store branch
      run: |
        REPO="${{ github.repository }}"
        FILE_PATH="android_reports.db"
        BRANCH="data-store"

        # Fetch file content from GitHub API
        RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.GITHUBTOKEN }}" \
          https://api.github.com/repos/$REPO/contents/$FILE_PATH?ref=$BRANCH)

        SHA=$(echo "$RESPONSE" | jq -r .sha)

        if [ "$SHA" != "null" ]; then
          echo "File found, downloading..."
          DOWNLOAD_URL=$(echo "$RESPONSE" | jq -r .download_url)
          curl -s -L $DOWNLOAD_URL -o $FILE_PATH
        else
          echo "File not found, proceeding without DB."
        fi

    - name: üï∑Ô∏è Run Scraper
      run: |
        python scrape.py

    - name: üíæ Commit updated DB to data-store branch using GitHub API
      env:
        GIT_AUTH_TOKEN: ${{ secrets.GITHUBTOKEN }}
      run: |
        # Encode the DB file to base64
        BASE64_DB=$(base64 -w 0 android_reports.db)

        COMMIT_MSG="üì¶ Update DB: $(date '+%Y-%m-%d %H:%M:%S')"
        REPO="${{ github.repository }}"
        FILE_PATH="android_reports.db"
        BRANCH="data-store"

        # Fetch the SHA if the file already exists
        RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.GITHUBTOKEN }}" \
          https://api.github.com/repos/$REPO/contents/$FILE_PATH?ref=$BRANCH)
        SHA=$(echo "$RESPONSE" | jq -r .sha)

        # If the branch doesn't exist, create it
        if [ "$SHA" == "null" ]; then
          echo "Branch $BRANCH does not exist. Creating..."
          # Create the branch based on the main branch
          git checkout -b $BRANCH origin/main
        fi

        # Create the JSON payload for the GitHub API
        JSON=$(jq -n \
          --arg msg "$COMMIT_MSG" \
          --arg content "$BASE64_DB" \
          --arg branch "$BRANCH" \
          '{message: $msg, content: $content, branch: $branch}')

    - name: üìä Compare with Existing Data and Check for New Vulnerabilities
      id: compare
      run: |
        # Compare newly scraped vulnerabilities with the database
        if [ -f android_reports.db ]; then
          # Assuming the `scrape.py` adds vulnerabilities to the database (e.g., `new_reports`)
          new_reports_count=$(sqlite3 android_reports.db "SELECT COUNT(*) FROM new_reports;")
          echo "New vulnerabilities found: $new_reports_count"

          if [ "$new_reports_count" -gt 0 ]; then
            echo "new_data=true" >> $GITHUB_OUTPUT
            echo "$new_reports_count" > new-found.flag
          else
            echo "new_data=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "new_data=false" >> $GITHUB_OUTPUT
        fi

    - name: üîî Send Slack Notification if New Vulnerabilities Found
      if: steps.compare.outputs.new_data == 'true'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      run: |
        COUNT=$(cat new-found.flag)
        MESSAGE="üì± *$COUNT* new Android vulnerability disclosures found on HackerOne!\n‚û°Ô∏è Check reports: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        curl -X POST -H 'Content-type: application/json' \
          --data "{\"text\":\"$MESSAGE\"}" \
          "$SLACK_WEBHOOK_URL"

    

        # Upload the
